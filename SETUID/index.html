<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SetUID ATTACK VECTOR</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <center>
        <h1>SETUID ATTACK</h1>
        <img src="logo.jpeg" alt="logo" height="30%" width="30%">
    </center>
       <div class="main">
        <h3>
            üåüÔ∏è Introduction :
        </h3>
        <p>
            Setuid, which stands for set user ID on execution, is a special type of file permission in Unix and Unix-like operating systems such as Linux and BSD. It is a security tool that permits users to run certain programs with escalated privileges.
When an executable file's setuid permission is set, users may execute that program with a level of access that matches the user who owns the file. For instance, when a user wants to change their password, they run the passwd command. The passwd program is owned by the root account and marked as setuid, so the user is temporarily granted root access for that limited purpose.
        </p>
        <br>
        <hr>
        <h3>
            üåüÔ∏è File modes Viewing the setuid permission of a file :
        </h3>
        <p>
            üåüÔ∏è When viewing a file's permissions with the ls -l command, the setuid permission is displayed as an "s" in the "user execute" bit position
            <br>
            <br>
            Example :
            <br>
            ls -l /usr/bin/passwd
        </p>
        <hr>
        <h3>
            üåüÔ∏è Setting the setuid permission of a file :
        </h3>
        <p>
            To set the setuid permission for an executable file, use the permission identifier u+s with the chmod command:  chmod u+s myfile</p>
            <p>Non-executable files can be marked as setuid, but it has no effect; marking them setuid does not automatically make them executable. In this case, the permission bit shows up as an uppercase "S". For instance:  ls -l myfile</p>
            <p>However, if you then set the file to be user-executable with the permission u+x, the setuid permission comes into effect. It's then represented in the listing with a lowercase "s":
                chmod u+x myfile
                <br>
                ls -l myfile</p>
             </p>
             <hr>
             <h3>
                üåüÔ∏è Setgid
             </h3>
             <p>
                Setgid is the equivalent of setuid for groups. If the bit is set, it grants permission of the group who owns the file. In a file listing, the "s" (lowercase s) character is listed in the "group execute" position of the file permissions string. If the setgid bit is set, but the group does not have execute permissions, an uppercase "S" is displayed instead. This uppercase character indicates that the bit is set, but has no effect.
                <br>
                In the of the output of ls -l shown here, the lowercase "s" indicates that the setgid bit is set for the listed file. Any user who accesses that file will do so as if they are a member of the owning group.
                <p>chmod g+s myfile2
                    <br>
                    ls -l myfile2</p>
                   
                    <p>If the setgid bit is set for a directory, any new files created are owned by the directory's owning group, instead of the user's group. Files moved or copied from another location will not have their group ID modified.</p>
             </p>
             <hr>
             <h3>
                üåüÔ∏è File modes
             </h3>
             <p>
                The setuid and setgid bits are normally represented as the values 4 for setuid and 2 for setgid in the high-order octal digit of the file mode. For example, 6711 has both the setuid and setgid bits (4 + 2 = 6) set, and also the file read/write/executable for the owner (7), and executable by the group (first 1) and others (second 1). Most implementations have a symbolic representation of these bits; in the previous example, this could be u=rwx,go=x,ug+s.

                Typically, chmod does not have a recursive mode restricted to directories, so modifying an existing directory tree must be done manually, with a command such as find /path/to/directory -type d -exec chmod g+s '{}' '\'. 
              </p>
              <hr>
              <h3>
                üåüÔ∏è Effects
              </h3>
              <p>
                The setuid and setgid flags have different effects, depending on whether they are applied to a file, to a directory or binary executable or non binary executable file. The setuid and setgid flags have an effect only on binary executable files and not on scripts (e.g., Bash, Perl, Python)
            </p>
            <h3>
                üåüÔ∏è When set on an executable file
            </h3>
            <p>
                When the setuid or setgid attributes are set on an executable file, then any users able to execute the file will automatically execute the file with the privileges of the file's owner (commonly root) and/or the file's group, depending upon the flags set. This allows the system designer to permit trusted programs to be run which a user would otherwise not be allowed to execute. These may not always be obvious. For example, the ping command may need access to networking privileges that a normal user cannot access; therefore it may be given the setuid flag to ensure that a user who needs to ping another system can do so, even if their own account does not have the required privilege for sending packets. 
            </p>
            <h3>üåüÔ∏è Security impact</h3>
            <p>
                For security purposes, the invoking user is usually prohibited by the system from altering the new process in any way, such as by using ptrace, LD_LIBRARY_PATH or sending signals to it, to exploit the raised privilege, although signals from the terminal will still be accepted.

While the setuid feature is very useful in many cases, its improper use can pose a security risk if the setuid attribute is assigned to executable programs that are not carefully designed. Due to potential security issues, many operating systems ignore the setuid attribute when applied to executable shell scripts.

The presence of setuid executables explains why the chroot system call is not available to non-root users on Unix. See limitations of chroot for more details. 
            </p>
            <hr>
            <h3>üåüÔ∏è When set on a directory</h3>
            <p>Setting the setgid permission on a directory causes files and subdirectories created within to inherit its group ownership, rather than the primary group of the file-creating process. Created subdirectories also inherit the setgid bit. The policy is only applied during creation and, thus, only prospectively. Directories and files existing when the setgid bit is applied are unaffected, as are directories and files moved into the directory on which the bit is set.

                Thus is granted a capacity to work with files amongst a group of users without explicitly setting permissions, but limited by the security model expectation that existing files permissions do not implicitly change.
                
                The setuid permission set on a directory is ignored on most UNIX and Linux systems.[5][citation needed] However FreeBSD can be configured to interpret setuid in a manner similar to setgid, in which case it forces all files and sub-directories created in a directory to be owned by that directory's owner - a simple form of inheritance. This is generally not needed on most systems derived from BSD, since by default directories are treated as if their setgid bit is always set, regardless of the actual value. As is stated in open(2), "When a new file is created it is given the group of the directory which contains it."</p>
                <hr>
                <h3>üåüÔ∏è Security</h3>
                <p>Developers design and implement programs that use this bit on executables carefully in order to avoid security vulnerabilities including buffer overruns and path injection. Successful buffer-overrun attacks on vulnerable applications allow the attacker to execute arbitrary code under the rights of the process exploited. In the event that a vulnerable process uses the setuid bit to run as root, the code will execute with root privileges, in effect giving the attacker root access to the system on which the vulnerable process is running.

                    Of particular importance in the case of a setuid process is the environment of the process. If the environment is not properly sanitized by a privileged process, its behavior can be changed by the unprivileged process that started it. For example, GNU libc was at one point vulnerable to an exploit using setuid and an environment variable that allowed executing code from untrusted shared libraries.</p>
                    <hr>
                    <h3>üåüÔ∏è Protecting setuid and setgid Programs</h3>
                    <p>Set user ID (setuid) programs are among the most frequently used programs at a UNIX site. A process that invokes a setuid program automatically acquires the identity of the owner of the setuid program. If the owner of a setuid program is root, then any user automatically becomes a superuser by invoking the setuid program. When the setuid program starts, the process performs any task which a superuser has permission for. Ensure that the setuid programs perform only the required task. Back doors or shells within a setuid program grant the user access to everything on the system.
                        CA ControlMinder uses the PROGRAM class to protect setuid and setgid programs. Upon installation, CA ControlMinder permits any program execution by default. After defining trusted programs in the database, you can change the behavior of CA ControlMinder so that execution of a setuid or setgid program is prohibited unless the program is defined as a trusted program.</p>
             </div>
             <hr>
             <h1>Thanks for Visiting</h1>
</body>
</html>